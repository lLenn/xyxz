const Mocha = require("mocha");
const browserify = require("browserify");
const mold = require("mold-source-map");
const NiXPSITWebdriver = require("./nixpsit-test-webdriver.js");
const config = require("./nixpsit-test-config.js");
const api = require("./nixpsit-test-api.js");
const path = require("path");
const url = require("url");
const fs = require("fs");

class Testing {
	constructor() {
		this.translationsToLoad = [];
		this.stylesToLoad = [];
		this.scriptsToLoad = [];
		this.scriptsToBrowserify = [];
		this.testsToBrowserify = [];
		this.unitTestsToRun = [];
		this.funcTestsToRun = [];
		this.testData = {};
		this.testDirectory;
		this.appDirectory;
		this.activeBrowser;
		this.reloadPage;
		
		this.loginCallback;
		this.webdrivers = { 
			chrome: { loggedInAs: undefined, loggedInWith: undefined, instance: undefined },
			firefox: { loggedInAs: undefined, loggedInWith: undefined, instance: undefined }
		};
	}
	
	setActiveBrowser(browser) {
		this.activeBrowser = browser;
	}
	
	setAPPDirectory(dir) {
		this.appDirectory = dir;
	}

	getAPPDirectory() {
		return this.appDirectory;
	}

	setTestDirectory(dir) {
		this.testDirectory = dir;
	}

	getTestDirectory() {
		return this.testDirectory;
	}
	
	setLoginCallback(callback) {
		this.loginCallback = callback;
	}
	
	async login(name, password) {
		if(this.webdrivers[this.activeBrowser].instance === undefined || this.webdrivers[this.activeBrowser].loggedInAs !== name) {
			this.webdrivers[this.activeBrowser].loggedInAs = name;
			this.webdrivers[this.activeBrowser].loggedInWith = password;
			if(this.webdrivers[this.activeBrowser].instance === undefined) {
				this.webdrivers[this.activeBrowser].instance = new NiXPSITWebdriver();
				this.webdrivers[this.activeBrowser].instance.open(this.activeBrowser);
			}
			await this.loginCallback.call(null, this.webdrivers[this.activeBrowser].instance.getWebdriver(), name, password);
		}
	}

	async close() {
		for(let prop in this.webdrivers) {
			if(this.webdrivers[prop].instance !== undefined) {
				await this.webdrivers[prop].instance.close();
			}
		}
	}
	
	async runMochaTests(file, init, grep) {
		try {
			let webdriver = this.webdrivers[this.activeBrowser].instance.getWebdriver();
			await this.webdrivers[this.activeBrowser].instance.get(file);
			await this._prepareWebdriverForTests(webdriver, true);
			for(let i = 0, len = init.length; i < len; i++) {
				var stats = fs.statSync(init[i]);
				if(stats.isDirectory() === true) {
					await this.addDirectory(init[i]);
				} else {
					await this.webdrivers[this.activeBrowser].instance.addScriptAsync(init[i]);
				}
			}
			await webdriver.executeScript(function(pGrep) { mocha.grep(new RegExp(pGrep)) }, grep);
			await webdriver.executeScript(function(pTestVariables) { window.testVariables = pTestVariables; }, this.testData);
			if((await this.browserifyScripts(true)) === true) {
				await this.webdrivers[this.activeBrowser].instance.loadAll([__dirname + "/temp/gulp.js"]);
			}
			await this.webdrivers[this.activeBrowser].instance.loadAll(this.unitTestsToRun);
			let that = this;
			await new Promise(function(resolve, reject) {
				that.webdrivers[that.activeBrowser].instance.setMochaResolve(resolve);
				webdriver.executeScript(function() { mocha.run(); });
			});
		} catch(e) {
			throw e;
		}
	}
	
	async addDirectory(pPath) {
		var files = fs.readdirSync(pPath);
		for(var i = 0, len = files.length; i < len; i++) {
			var url = path.resolve(pPath, files[i]);
			var stats = fs.statSync(url);
			if(stats.isDirectory() === true) {
				await this.addDirectory(url);
			} else {
				await this.webdrivers[this.activeBrowser].instance.addScriptAsync(url);
			}
		}
	}
	
	async runFunctionalTests(template, init, grep) {
		let that = this;
		let webdriver = await this.webdrivers[this.activeBrowser].instance.getWebdriver();
		this.reloadPage = template;
		await this.webdrivers[this.activeBrowser].instance.get(template);
		await this._prepareWebdriverForTests(webdriver, false);
		if((await this.browserifyScripts(false)) === true) {
			await this.webdrivers[this.activeBrowser].instance.loadAll([__dirname + "/temp/gulp.js"]);
		}
		await new Promise(function(resolve, reject) {
			try {
				let mocha = new Mocha();
				if(require.cache[path.resolve(init)] !== undefined) {
					delete require.cache[path.resolve(init)];
				}
				mocha.addFile(path.resolve(init));
				for(var i = 0, len = that.funcTestsToRun.length; i < len; i++) {
					let item = that.funcTestsToRun[i];
					if(item[0] === "." && (item[1] === "/" || item[1] === "\\")) {
						item = item.substring(1);
					}
					if(require.cache[path.resolve(item)] !== undefined) {
						delete require.cache[path.resolve(item)];
					}
					mocha.addFile(path.resolve(item));
				}
				mocha.grep(new RegExp(grep));
				mocha.run(function(failures) {
					resolve(failures);
				});
			} catch(e) {
				reject(e);
			}
		});
	}
	
	async reloadBrowserFunctionalTests() {
		let activeBrowser = this.webdrivers[this.activeBrowser];
		await this.loginCallback.call(null, activeBrowser.instance.getWebdriver(), activeBrowser.loggedInAs, activeBrowser.loggedInWith);
		await activeBrowser.instance.get(this.reloadPage);
		await this._prepareWebdriverForTests(activeBrowser.instance.getWebdriver());
	}

	browserifyScripts(unit) {
		if(this.scriptsToBrowserify.length > 0 || (unit === true && this.testsToBrowserify.length > 0)) {
			var b = browserify({ debug: true });
			for(var i = 0, len = this.scriptsToBrowserify.length; i < len; i++) {
				b.add(this.scriptsToBrowserify[i]);
			}
			if(unit === true) {
				for(var i = 0, len = this.testsToBrowserify.length; i < len; i++) {
					b.add(this.testsToBrowserify[i]);
				}
			}
			return new Promise(function(resolve, reject) {
				b.bundle()
					.on("error", reject)
					.pipe(mold.transform(function(sourcemap, cb) {
						sourcemap.sourceRoot("file:///");
						fs.writeFile(__dirname + "/temp/gulp.map", sourcemap.toJSON(4), 'utf-8', function(err) {
							cb('//@ sourceMappingURL=file:///' + __dirname + "/temp/gulp.map");
						});
					}))
					.pipe(fs.createWriteStream(__dirname + "/temp/gulp.js").on("finish", () => resolve(true)));
			});
		} else {
			return false;
		}
	}
	
	async _prepareWebdriverForTests(webdriver) {
		let apiIndex = this.scriptsToLoad.indexOf(config.getSetting("authority") + "/?api=js");
		if(apiIndex !== -1) {
			await this.webdrivers[this.activeBrowser].instance.addScriptAsync(this.scriptsToLoad[apiIndex]);
			await webdriver.executeScript(function(pAddress) { portal_api_base.m_address = pAddress; api_async.m_address = pAddress; api_sync.m_address = pAddress; }, config.getSetting("authority") + "/portal.cgi");

			if(api.getSessionID() !== undefined) {
				await webdriver.executeScript(function(pSessionID) { portal_api_base.m_session = pSessionID; api_async.m_session = pSessionID; api_sync.m_session = pSessionID; }, api.getSessionID());
			}
			this.scriptsToLoad.splice(apiIndex, 1);
		}
		await this.webdrivers[this.activeBrowser].instance.loadAllStyles(this.stylesToLoad);
		await this.webdrivers[this.activeBrowser].instance.loadAll(this.scriptsToLoad);
		await this.webdrivers[this.activeBrowser].instance.loadTranslations(this.translationsToLoad);
		if(apiIndex !== -1) {
			this.scriptsToLoad.push(config.getSetting("authority") + "/?api=js");
		}
	}
	
	clearScriptsAndTests() {
		this.stylesToLoad = [];
		this.scriptsToLoad = [];
		this.unitTestsToRun = [];
		this.funcTestsToRun = [];
		this.scriptsToBrowserify = [];
		this.testsToBrowserify = [];
	}
	
	setTestData(data) {
		this.testData = data;
	}
	
	getTestData(data) {
		return this.testData;
	}
	
	addTranslations(source) {
		if(this.translationsToLoad.indexOf(source) === -1) {
			this.translationsToLoad.push(source);
		}
	}

	addCSS(source) {
		this.addStyle(source);
	}
	
	addStyle(source) {
		if(this.stylesToLoad.indexOf(source) === -1) {
			this.stylesToLoad.push(source);
		}
	}
	
	addScript(source) {
		if(this.scriptsToLoad.indexOf(source) === -1) {
			this.scriptsToLoad.push(source);
		}
	}

	addGulpRoot(source) {
		if(this.scriptsToBrowserify.indexOf(source) === -1) {
			this.scriptsToBrowserify.push(source);
		}
	}

	addGulpTest(source) {
		if(this.testsToBrowserify.indexOf(source) === -1) {
			this.testsToBrowserify.push(source);
		}
	}
	
	addUnitTest(source) {
		this.addTest(source, "UnitTest");
	}
	
	addFunctionalTest(source) {
		this.addTest(source, "FunctionalTest");
	}
	
	getWebdriver() {
		return this.webdrivers[this.activeBrowser].instance.getWebdriver();
	}

	addTest(source, type) {
		if(source.indexOf("http://") === -1 && source.indexOf("https://") === -1) {
			var source = path.resolve(this.testDirectory + source);
		}
		if([undefined, "UnitTest", "FunctionalTest"].indexOf(type) === -1) {
			throw new Error(`Argument isn't supported: ${type}`);
		}
		if((type === undefined || type === "UnitTest") && this.unitTestsToRun.indexOf(source) === -1) {
			this.unitTestsToRun.push(source);
		} else if(type === "FunctionalTest" && this.funcTestsToRun.indexOf(source) === -1) {
			this.funcTestsToRun.push(source);
		}
	}
}

module.exports = new Testing();