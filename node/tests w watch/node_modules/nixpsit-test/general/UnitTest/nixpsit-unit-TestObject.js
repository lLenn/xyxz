if(typeof require !== "undefined") {
	var ObjectType = require("./types/nixpsit-unit-ObjectType.js");
	var ParentType = require("./types/nixpsit-unit-ParentType.js");
	var _ = require('lodash');
}

(function() {
	var OBJECTS_NOT_TO_COPY = []
	if(typeof HTMLDocument !== "undefined") {
		OBJECTS_NOT_TO_COPY.push(HTMLDocument);
	}
	if(typeof DocumentType !== "undefined") {
		OBJECTS_NOT_TO_COPY.push(DocumentType);
	}
	if(typeof HTMLElement !== "undefined") {
		OBJECTS_NOT_TO_COPY.push(HTMLElement);
	}
	if(typeof jQuery !== "undefined") {
		OBJECTS_NOT_TO_COPY.push(jQuery);
	}
	
	TestObject = function(definition, allCombinations, depth, parent) {
		if(allCombinations === undefined) {
			allCombinations = false;
		}
		if(depth === undefined) {
			depth = 0;
		}
		this.definition = TestObject.copyObject(definition);
		this.parent = parent;
		this.object = {};
		this.allCombinations = allCombinations;
		this.workingProperties = definition!==undefined?definition.properties.map(function(pItem) { return pItem.name; }):[];
		this.uIDs = [];
		this.depth = depth;
		
		this.setToDefaultObject();
	}

	TestObject.MAX_DEPTH_TEST_OBJECT = 3;
	
	TestObject.copyObject = function(object, depth, copiedObjects, withoutCircularRefs) {
		if(depth === undefined) {
			depth = 0;
		}
		if(copiedObjects === undefined) {
			copiedObjects = [];
		}
		if(withoutCircularRefs === undefined) {
			withoutCircularRefs = false;
		}
		if(depth === 255) {
			return;
		}
		var pointer;
		if(Array.isArray(object) === true) {
			var copy = [];
			for(var i = 0, len = object.length; i < len; i++) {
				copy[i] = TestObject.copyObject(object[i], depth+1, copiedObjects, withoutCircularRefs);
			}
			return copy;
		} else if((pointer = TestObject.isCircular(object, copiedObjects)) !== null) {
			if(withoutCircularRefs === false) {
				return pointer;
			} else {
				return undefined;
			}
		} else if(TestObject.isValidObject(object, copiedObjects) === true) {
			var proto = Object.getPrototypeOf(object);
			if(proto === null) {
				var copy = Object.assign({}, object);
			} else {
				var copy = Object.assign(Object.create(proto), object);
			}
			copiedObjects.push({ original: object, copy: copy });
			for(var prop in object) {
				try {
					if(proto[prop] === undefined) {
						copy[prop] = TestObject.copyObject(object[prop], depth+1, copiedObjects, withoutCircularRefs);
					}
				} catch(e) {
					throw e;
				}
			}
			return copy;
		} else {
			return object;
		}
	}
	
	TestObject.getValue = function(pObject, pField) {
		if(pField !== undefined) {
		    var subKeys = pField.split('.');
		    var subObject = pObject;
		    for (var i = 0, len = subKeys.length; i < len; i++) {
		    	var subKey = subKeys[i];
	            if (subObject[subKey] === undefined) {
			        return;
	            }
	            subObject = subObject[subKey];
		    }
		    return subObject;
		} else {
			return pObject;
		}
	}

	TestObject.isCircular = function(pObject, pCopiedObjects) {
		for(var i = 0, len = pCopiedObjects.length; i < len; i++) {
			if(_.isEqual(pCopiedObjects[i].original, pObject) === true) {
				return pCopiedObjects[i].copy;
			}
		}

		return null;
	}

	TestObject.isValidObject = function(pObject) {
		if(pObject === null || typeof pObject !== "object" || Array.isArray(pObject) === true) {
			return false;
		}
		
		for(var i = 0, len = OBJECTS_NOT_TO_COPY.length; i < len; i++) {
			if(pObject instanceof OBJECTS_NOT_TO_COPY[i]) {
				return false;
			}
		}
		
		return true;
	}
	
	//ToDo: add type for functions which just does stuff and doesn't return anything, like an event function and mock function which should be skipped 
	TestObject.fillObject = function(pObject, pDepth) {
		if(pDepth === undefined) {
			pDepth = 0;
		}
		if(pDepth === 100) {
			return;
		}
		return $.Deferred(function(pDefer){
			var defers = [];
			if(Array.isArray(pObject) === true) {
				for(var i = 0, len = pObject.length; i < len; i++) {
					defers.push(TestObject.replaceFunction(pObject, prop, pDepth));
				}
			} else if(TestObject.isValidObject(pObject) === true) {
				for(var prop in pObject) {
					defers.push(TestObject.replaceFunction(pObject, prop, pDepth));
				}
			}
			$.when.apply($, defers).then(pDefer.resolve, pDefer.reject, pDefer.progress);
		});
	}
	
	TestObject.replaceFunction = function(pObject, pProp, pDepth) {
		if(typeof pObject[pProp] === "function") {
			return $.Deferred(function(pDefer) {
				$.when(pObject[pProp]()).then(function(pResult) {
					$.when(TestObject.fillObject(pResult, pDepth+1)).then(function() {
						pObject[pProp] = pResult;
						pDefer.resolve();
					}, pDefer.reject, pDefer.progress);
				}, pDefer.reject, pDefer.progress);
			})
		} else {
			return TestObject.fillObject(pObject[pProp], pDepth+1);	
		}
	}
	
	TestObject.prototype = {
		constructor: TestObject,
		
		setNextState: function() {
			if(this.definition === undefined) {
				return false;
			}
			var currentPropertyPointer = this.definition.propertyPointer;
			this._setUID();
			var value = this.definition.next(this);
			if(value instanceof EndOfType) {
				return false;
			}
			if(this.allCombinations === true && currentPropertyPointer !== this.definition.propertyPointer) {
				this.setToDefaultObject(this.definition.propertyPointer);
			}
			this.object[this.definition.current().name] = value;
			this._adjustLinks(this.definition.current().name);
			if(this.allCombinations === true && currentPropertyPointer !== this.definition.propertyPointer) {
				this.definition.reset();
			}
			return true;
		},
		
		getCurrentState: function() {
			return this.object;
		},
		
		createRandomObject: function(pCondition, pDepth) {
			if(pDepth === undefined) {
				pDepth = 0;
			}
			if(pDepth === 255) {
				throw new Error("Unable to create random object! Please check if the conditions allow for the creation thereof!");
			}
			var testObject = new TestObject(this.definition, this.allCombinations, this.depth, this.parent);
			for(var i = 0, len = this.workingProperties.length; i < len; i++) {
				var prop = this.workingProperties[i];
				if(this.definition.getProperty(prop).types.indexOf("uniqID") === -1) {
					if(this.definition.getProperty(prop).required === false && Math.floor(Math.random()*2) === 0) {
						testObject.object[prop] = undefined;
					} else if(this.definition.getProperty(prop).required === false && Math.floor(Math.random()*2) === 1) {
						testObject.object[prop] = null;
					} else {
						var randType = Math.floor(Math.random() * (this.definition.getProperty(prop).types.length-1));
						if(this.definition.getProperty(prop).types[randType] === "object" && this.definition.getProperty(prop).callback === undefined) {
							testObject.object[prop] = new ObjectType(this.definition.getProperty(prop).required, this.definition.getProperty(prop).objectDefinition, true).getValue(0, testObject);
						} else if(this.definition.getProperty(prop).types[randType] === "parent") {
							testObject.object[prop] = new ParentType(this.definition.getProperty(prop).required, this.definition.getProperty(prop).callback).getValue(0, testObject);
						} else {
							testObject.object[prop] = this.definition.getProperty(prop).getTypeObject(randType).getRandom(testObject);
						}
					}
					this._adjustLinks(prop, testObject);
				} else if(this.definition.getProperty(prop).types.indexOf("uniqID") !== -1) {
					testObject.object[prop] = this.generateUID();
				}
			}
			if(typeof pCondition === "function" && pCondition.call(null, testObject.object) === false) {
				return this.createRandomObject(pCondition, pDepth+1);
			} else {
				return testObject.object;
			}
		},
		
		setToDefaultObject: function(untilIndex) {
			this._setUID();
			if(untilIndex === undefined) {
				untilIndex = this.workingProperties.length;
			}
			for(var i = 0; i < untilIndex; i++) {
				if(this.definition.getProperty(this.workingProperties[i]).types.indexOf("uniqID") === -1) {
					this.definition.getProperty(this.workingProperties[i]).reset();
					this.object[this.workingProperties[i]] = this.definition.getProperty(this.workingProperties[i]).next(this);
					this._adjustLinks(this.workingProperties[i]);
				}
			}
		},
		
		_setUID: function() {
			for(var i = 0, len = this.workingProperties.length; i < len; i++) {
				if(this.definition.getProperty(this.workingProperties[i]).types.indexOf("uniqID") !== -1) {
					this.object[this.workingProperties[i]] = this.generateUID();
				}
			}
		},
		
		_adjustLinks: function(prop, testObject) {
			if(testObject === undefined) {
				testObject = this;
			}
			for(var i = 0, len = this.workingProperties.length; i < len; i++) {
				var property = this.definition.getProperty(this.workingProperties[i]);
				if(property.linkedWith !== undefined && property.linkedWith.indexOf(prop) !== -1) {
					if(typeof property.callback !== "function") {
						throw new Error("A definition with 'linkedWith' should have the 'callback' property added!")
					}
					testObject.object[this.workingProperties[i]] = property.getTypeObject(0).getLink(testObject);
				}
			}
		},
		
		s4: function() {
		    return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
		},
		
		generateUID: function() {
			do {
				var uid = this.s4() + this.s4() + '-' + this.s4() + '-' + this.s4() + '-' + this.s4() + '-' + this.s4() + this.s4() + this.s4();
			}
			while(this.uIDs.indexOf(uid) !== -1);
			this.uIDs.push(uid)
			return uid;
		}
	}
})();

if(typeof module !== "undefined") {
	module.exports = TestObject;
}