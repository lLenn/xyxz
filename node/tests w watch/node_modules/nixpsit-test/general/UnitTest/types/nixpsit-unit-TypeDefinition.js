if(typeof require !== "undefined") {
	var Filter = require("../filters/nixpsit-unit-Filter.js");
	var EndOfType = require("./nixpsit-unit-EndOfType.js");
}

(function() {
	TypeDefinition = function(pRequired, pFilter) {
		if(typeof this.next !== "function") {
			throw new Error("Classes of the TypeDefinition interface should implement the getValue method!");
		}
		if(pFilter === undefined) {
			pFilter = new Filter();
		}
		this.required = pRequired;
		if(this.required === false) {
			this.pointer = 0;
		} else {
			this.pointer = 2;
		}
		this.filter = pFilter;
	}
	
	TypeDefinition.prototype = {
		constructor: TypeDefinition,
		
		next: function(pTestObject) {
			if(this.required === false && this.pointer === 0) {
				this.pointer++;
				return undefined;
			} else if(this.required === false && this.pointer === 1) {
				this.pointer++;
				return null;
			} else { 
				if(this.pointer < 2) {
					this.pointer = 2;
				}
				this.pointer++;
				if(this.pointer === 100) {
					throw new Error(this.constructor.name + ": Possible eternal loop detected! Make sure that the class which implements the getValue method of the TypeDefinition interface returns EndOfType instance at some point!");
				}
				var value = this.getValue(this.pointer-3, pTestObject);
				if(!(value instanceof EndOfType) && this.filter.compare(value) === false) {
					return this.next(pTestObject);
				}
				return value;
			}
		},
		
		getMaxPointer: function(pTestObject) {
			var pointer = 0;
			while((this.getValue(pointer, pTestObject) instanceof EndOfType) === false) {
				pointer++;
				if(pointer === 100) {
					throw new Error("Possible eternal loop detected! Make sure that the class which implements the getValue method of the TypeDefinition interface returns EndOfType instance at some point!");
				}
			}
			return pointer;
		},
		
		getRandom: function(pTestObject, pDepth) {
			if(pDepth === undefined) {
				pDepth = 0;
			}
			if(pDepth === 100) {
				throw new Error("Possible eternal loop detected! Make sure that the filter on the class compares correct values and doesn't exlude all possibilities!");
			}
			var randPointer = Math.floor(Math.random() * this.getMaxPointer(pTestObject));
			var value = this.getValue(randPointer, pTestObject);
			if(!(value instanceof EndOfType) && this.filter.compare(value) === false) {
				return this.getRandom(pTestObject, pDepth + 1);
			}
			return value;
		},
	
		reset: function() {
			if(this.required === false) {
				this.pointer = 0;
			} else {
				this.pointer = 2;
			}
		}
	}
})()

if(typeof module !== "undefined") {
	module.exports = TypeDefinition;
}