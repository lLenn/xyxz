if(typeof require !== "undefined") {
	var StringType = require("./types/nixpsit-unit-StringType.js");
	var BooleanType = require("./types/nixpsit-unit-BooleanType.js");
	var NumberType = require("./types/nixpsit-unit-NumberType.js");
	var DateType = require("./types/nixpsit-unit-DateType.js");
	var ArrayType = require("./types/nixpsit-unit-ArrayType.js");
	var ParentType = require("./types/nixpsit-unit-ParentType.js");
	var ObjectType = require("./types/nixpsit-unit-ObjectType.js");
	var TestType = require("./types/nixpsit-unit-TestType.js");
	var ValuesType = require("./types/nixpsit-unit-ValuesType.js");
	var LinkedType = require("./types/nixpsit-unit-LinkedType.js");

	var NumberFilter = require("./filters/nixpsit-unit-NumberFilter.js");
	var DateFilter = require("./filters/nixpsit-unit-DateFilter.js");
}

(function() {
	const ALLOWED_DEFINITION_TYPES = ["string", "number", "date", "date_unix_epoch", "date_ISO", "array", "boolean", "object", "test", "uniqID", "parent", "values", "function", "linked"];
	
	PropertyDefinition = function(pName, pTypes) {
		if(Array.isArray(pTypes) === false) {
			throw new Error("PropertyDefinition: constructor expects an array as second argument!");
		}
		this.name = pName;
		this.types = pTypes;
		this.typeObjects = [];
		this.typesPointer = 0;
		this.required = true;
		this.empty = true;
		this.linkedWith;
		this.objectDefinition;
		this.filter = { comparison: undefined, value: undefined };
		this.callback;
		
		this._validate();
	}
	
	PropertyDefinition.prototype = {
		constructor: PropertyDefinition,
		
		isNotRequired: function() {
			this.required = false;
			
			return this;
		},
		
		chooseFrom: function(pValues) {
			if(typeof pValues !== "function" && Array.isArray(pValues) === false) {
				throw new Error("PropertyDefinition: chooseFrom expects an array or function as first argument!");
			}
			this.types = ["values"];
			this.callback = pValues;
			
			return this;
		},
		
		canNotBeEmpty: function() {
			this.empty = false;
			
			return this;
		},
		
		isLinkedWith: function(pLink) {
			if(Array.isArray(pLink) === false) {
				throw new Error("PropertyDefinition: isLinkedWith expects an array as first argument!");
			}
			this.types = ["linked"];
			this.linkedWith = pLink;
			
			return this;
		},
		
		hasLengthOf: function(pLength) {
			this.lengthOf = pLength;
			
			return this;
		},
		
		withFilter: function(pComparison, pValue) {
			this.filter = { comparison: pComparison, value: pValue };
			
			return this;
		},
		
		ofType: function(pObjectDefinition) {
			if(ObjectDefinition.isObjectDefinitionConstructor(pObjectDefinition) === true) {
				this.objectDefinition = new pObjectDefinition();
			} else {
				throw new Error("PropertyDefinition: type '" + pObjectDefinition + "' isn't of the class ObjectDefinition!");
			}
			return this;
		},
		
		withCallback: function(pCallback) {
			this.callback = pCallback;
			
			return this;
		},
		
		next: function(pTestObject) {
			if(this.typesPointer === this.types.length) {
				return new EndOfType();
			}
			var value = this.getTypeObject(this.typesPointer).next(pTestObject);
			if(value instanceof EndOfType) {
				this.getTypeObject(this.typesPointer).reset();
				this.typesPointer++;
				return this.next(pTestObject);
			}
			return value;
		},
		
		reset: function() {
			this.typesPointer = 0;
			for(var i = 0, len = this.types.length; i < len; i++) {
				this.getTypeObject(i).reset();
			}
		},
		
		getTypeObject: function(pIndex) {
			if(this.typeObjects[pIndex] === undefined) {
				this.typeObjects[pIndex] = this._getTypeValues(this.types[pIndex]);
			}
			return this.typeObjects[pIndex];
		},
		
		//ToDo: add filter for other types
		_getTypeValues: function(pType) {
			switch(pType) {
				case "string": return new StringType(this.required, this.empty);
				case "boolean": return new BooleanType(this.required);
				case "number": return new NumberType(this.required, new NumberFilter(this.filter.comparison, this.filter.value));
				case "date": return new DateType(this.required, new DateFilter(this.filter.comparison, this.filter.value), "all");
				case "date_unix_epoch": return new DateType(this.required, new DateFilter(this.filter.comparison, this.filter.value), "unix_epoch");
				case "date_ISO": return new DateType(this.required, new DateFilter(this.filter.comparison, this.filter.value), "ISO");
				case "array": return new ArrayType(this.required, this.empty, this.objectDefinition, this.length);
				case "parent": return new ParentType(this.required, this.callback);
				case "object": return new ObjectType(this.required, this.objectDefinition, false);
				case "test": return new TestType(this.required);
				case "values": return new ValuesType(this.required, this.callback);
				case "linked": return new LinkedType(this.required, this.callback);
				default: throw new Error("PropertyDefinition: Type " + pType + " isn't supported!");
			}
		},
		
		_validate: function() {
			for(var i = 0, len = this.types.length; i < len; i++) {
				if(ALLOWED_DEFINITION_TYPES.indexOf(this.types[i]) === -1) {
					throw new Error("PropertyDefinition: Type '" + this.types[i] + "' isn't supported!");
				}
			}
		}
	}
	
})()

if(typeof module !== "undefined") {
    module.exports = PropertyDefinition;
}