const webdriver = require("selenium-webdriver");
const { By } = webdriver;
const { expect } = require("chai");
const Locator = require("./nixpsit-functional-Locator.js");
const Component = require("./nixpsit-functional-Component.js");
const utilities = require("../nixpsit-test-utilities.js");

class Widget extends Component {
	constructor(pWebdriver, pComponent, pComponentOptions, pLocator) {
		if(pWebdriver === undefined) {
			throw new Error(this.constructor.name + ": 'pWebdriver' cannot be undefined!");
		}
		var guid = utilities.generateGUID();
		if(pLocator === undefined || !(pLocator instanceof Locator)) {
			pLocator = new Locator(By.css("." + guid));
		}
		super(pWebdriver, pLocator);
		this.guid = guid;
		var componentNamespace = pComponent.split(".");
		if(componentNamespace.length < 2) {
			throw new Error("Widget: Component should include namespace!");
		}
		this.componentNamespace = componentNamespace[0];
		this.componentName = componentNamespace[1];
		this.componentOptions = pComponentOptions;
	}
	
	async create(pTimeout) {
		if(pTimeout === undefined) {
			pTimeout = 10000;
		}
		var element = await this.findElements();
		if(element.length === 0) {
			await this.webdriver.executeScript(function(pGUID, pComponentName, pComponentOptions) {
				document.hasRendered = false;
				$(document.body).append($("<div style='margin: 50px'>").addClass(pGUID));
				$("." + pGUID).one("rendered", function() { document.hasRendered = true; });
				$("." + pGUID)[pComponentName](pComponentOptions);
			}, this.guid, this.componentName, this.componentOptions);
			var that = this;
			return new Promise(async function(pResolve, pReject) {
				var intervalID;
				var timeoutID = setTimeout(function() {
					clearInterval(intervalID);
					pReject("Element hasn't triggered 'rendered' event. Make sure it's implemented or increase the timeout!");
				}, pTimeout)
				intervalID = setInterval(async function() {
					var rendered = await that.webdriver.executeScript(function() { return document.hasRendered; });
					if(rendered === true) {
						clearInterval(intervalID);
						clearTimeout(timeoutID);
						pResolve();
					}
				}, 100);
			});
		}
	}
	
	async redraw() {
		await this.remove();
		await this.create();
	}

	async remove() {
		await this.webdriver.executeScript(function(pElement) {
			$(pElement).remove();
		}, await this.findElement());
	}
	
	async executeMethod(methodName, args) {
		return await this.webdriver.executeScript(function(pElement, pComponentName, pMethodName, pArgs) {
			return $(pElement)[pComponentName].apply($(pElement), [pMethodName].concat(pArgs));
		}, await this.findElement(), this.componentName, methodName, args);
	}

	async expectOptionToEqual(pOption, pValue) {
		if(typeof pValue === "object") {
			expect(await this.executeMethod("option", [pOption])).to.deep.equal(pValue);
		} else {
			expect(await this.executeMethod("option", [pOption])).to.equal(pValue);
		}
	}

	async expectOptionCloseTo(pOption, pValue) {
		expect(await this.executeMethod("option", [pOption])).closeTo(pValue, 0.00000000000001);
	}
}

module.exports = Widget;