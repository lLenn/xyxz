//Deprecated use UnitTest/Widget & UnitTest/TestObject
(function() {
	//Todo: make allowed variables in functions const;	
	const ALLOWED_VALIDATE_OPTIONS_TYPES = ["object", "string", "number", "function", "array"];
	const ALLOWED_DEFINITION_PROPERTIES = ["type", "required", "values", "objectType", "empty", "linkedWith", "length", "property"];
	const ALLOWED_DEFINITION_TYPES = ["string", "number", "date", "array", "boolean", "object", "test", "uniqID", "parent"];
	const ALLOWED_RULE_PROPERTIES = ["css", "cond", "value", "text", "attr", "className", "component", "iterate", "custom", "test", "contains", "empty", "length", "canBeUndefined", "hasToBe", "visible"];
	const MAX_DEPTH_TEST_OBJECT = 3;
	
	function copyObject(object) {
		if(typeof object !== "object") {
			return object;
		} else if(Array.isArray(object) === true) {
			var copy = [];
			for(var i = 0, len = object.length; i < len; i++) {
				copy[i] = copyObject(object[i]);
			}
			return copy;
		} else {
			var copy = Object.assign({}, object);
			for(var prop in object) {
				if(typeof object[prop] === "object") {
					copy[prop] = copyObject(object[prop]);
				}
			}
			return copy;
		}
	}
	
	/*
	 * @description: constructor
	 * @param {string} The tag on which to create the widget when needed
	 * @param {string} The component name of the widget to create
	 * @param {object} The rules:
	 *    Each property of the rules object correspondes to a property in the object.
	 *    The value of each property is an array with objects with following properties:
	 *    css {string|required}: is the css to search for in the element
	 *    text {boolean}: whether the value should be in the text of the element
	 *    attr {Array<string>}: an array with strings, which denotate in which attributes the value should be present, i.e. ["title"]
	 *    className {string}: a string that should be present in the class
	 *    component {object}: an object with following properties
	 *       name {string}: name of the component
	 *       options {array<string>}: an array with options to test against
	 *    cond {function(pObject)}: a function with as parameter the object, should return a boolean on whether this rule is applicable on the object
	 *    val {function(pObject)}: a function with as parameter the object, should return the value to test for
	 */
	WidgetUnitTestObject = function(elementTag, component, rules, optionsDefinition, objectDefinitions, methodDefinitions) {
		this.elementTag = elementTag;
		var componentNamespace = component.split(".");
		if($[componentNamespace[0]] === undefined || $.isFunction($[componentNamespace[0]][componentNamespace[1]]) === false) {
			throw new Error("Component " + component + " not found!");
		}
		this.componentNamespace = componentNamespace[0];
		this.componentName = componentNamespace[1];
		this.rules = copyObject(rules);
		this.optionsDefinition = copyObject(optionsDefinition);
		this.objectDefinitions = copyObject(objectDefinitions);
		this.methodDefinitions = copyObject(methodDefinitions);
		this.breakpoints = [];
		
		this._validateRules();
		this._validateDefinitions();
		
		this.element;
		this.parent;
	}
	
	WidgetUnitTestObject.prototype = {
		constructor: WidgetUnitTestObject,
		
		create: function(options) {
			this.element = $("<" + this.elementTag + ">")[this.componentName](options);
			if(this.parent !== undefined) {
				this.parent.empty();
				this.element.appendTo(this.parent);
			}
		},
		
		createRandom: function() {
			var testObject = new TestObject(this.optionsDefinition, this.objectDefinitions);
			this.create(testObject.createRandomObject());
		},
		
		setOption: function(options) {
			this.element[this.componentName]("option", options);
		},
		
		setParent: function(parent) {
			this.parent = parent;
		},
		
		expectElementCreateToPassAll: function(element) {
			if(element === undefined) {
				element = this.element;
			}
			
			var testObject = new TestObject(this.optionsDefinition, this.objectDefinitions);
			var state;
			do {
				state = testObject.getCurrentState();
				this.create(copyObject(state))
				this.expectElementToAbideByRules(state);
			} while(testObject.setNextState() === true)
			
			this.expectAllRulesTested();
		},
		
		expectElementRedrawToPassAll: function(element) {
			if(element === undefined) {
				element = this.element;
			}
			
			var testObject = new TestObject(this.optionsDefinition, this.objectDefinitions);
			var originalState = copyObject(testObject.getCurrentState());
			this.create(originalState);
			var state;
			while(testObject.setNextState() === true) {
				state = testObject.getCurrentState();
				this.setOption(copyObject(state));
				this.expectElementToAbideByRules(state);
			} 
			this.setOption(originalState);
			this.expectElementToAbideByRules(originalState);
				
			this.expectAllRulesTested();
		},
		
		/*
		 * @description: applies this.rules onto the element depending on the object
		 * @param {jQuery} The element
		 * @param {object} The object
		 */
		expectElementToAbideByRules: function(object, element, rules, args) {
			if(object === undefined) {
				object = this.element[this.componentName]("option");
			}
			if(element === undefined) {
				element = this.element;
			}
			if(rules === undefined) {
				rules = this.rules;
			}
			if(args === undefined) {
				args = [];
			}
			var that = this;
			this._iterateRules(rules, function(prop, rule) {
				try {
					if(rule["tested"] === undefined) {
						rule["tested"] = {};
					}
					
					for(var i = 0, len = that.breakpoints.length; i < len; i++) {
						if(that.breakpoints[i].call(null, object) === true) {
							debugger;
						}
					}
					
					if(rule.breakpoint !== undefined && rule.breakpoint === true) {
						rule["tested"].breakpoint = true;
						debugger;
					}
					
					if(rule.cond !== undefined) {
						rule["tested"].cond = true;
						if(rule.cond.hasToBe !== undefined) {
							if(rule.cond.hasToBe !== TestDefinition.getValue(object, prop)) {
								return;
							}
						} else {
							var condObject = copyObject(object);
							if(rule.cond.properties !== undefined) {
								for(var i = 0, len = rule.cond.properties.length; i < len; i++) {
									var condProp = rule.cond.properties[i];
									if(condProp.indexOf("__") === 0) {
										condProp = condProp.slice(2);
										value = element.data(that.componentNamespace + "-" + that.componentName)[condProp];
									} else {
										value = TestDefinition.getValue(object, condProp);
									}
									condObject[condProp] = value
								}
							}
							if(rule.cond.validation.call(null, condObject, args, that.element) === false) {
								return;
							}
						}
					}
					if(prop !== "__") {
						var elementChild = element.find(rule.css);
						var value = TestDefinition.getValue(object, prop);
						if(prop.indexOf("__") === 0) {
							value = element.data(that.componentNamespace + "-" + that.componentName)[prop.slice(2)];
						}
						if(rule.canBeUndefined !== undefined && rule.canBeUndefined === false && value === undefined) {
							return;
						}
						rule["tested"].canBeUndefined = true;
						var testValue = value;
						if(rule.iterate !== undefined) {
							rule["tested"].iterate = true;
							rule["tested"].css = true;
							if($.isArray(value) === false) {
								throw new Error("Property is not an array to iterate over for rule: " + JSON.stringify(rule));
							} else if(value.length !== elementChild.length) {
								throw new Error("Length of the array and elementChilds to iterate don't match for rule: " + JSON.stringify(rule));
							}
							for(var i = 0, len = elementChild.length; i < len; i++) {
								if(rule.value !== undefined) {
									rule["tested"].value = true;
									if(typeof rule.value === "function") {
										testValue = rule.value.call(null, object, value[i], args);
									} else {
										testValue = rule.value;
									}
								} else {
									testValue = value[i];
								}
								that._checkRule($(elementChild[i]), testValue, rule, object, args);
							}
						} else {
							if(rule.css !== undefined) {
								rule["tested"].css = true;
								if(rule.empty !== undefined && rule.empty === true) {
									rule["tested"].empty = true;
									expect(elementChild).to.have.length(0);
								} else {
									if(rule.empty !== undefined) {
										rule["tested"].empty = true;
									}
									expect(elementChild).to.have.lengthOf.at.least(1);
								}
							}
							if(rule.value !== undefined) {
								rule["tested"].value = true;
								if(typeof rule.value === "function") {
									testValue = rule.value.call(null, object, args);
								} else {
									testValue = rule.value;
								}
							}
							that._checkRule(elementChild, testValue, rule, object, args);
						}
					} else {
						if(typeof rule.test !== "function") {
							throw new Error("The rule with prop '__' should have a 'test' method implemented!")
						}
						rule["tested"].test = true;
						rule.test.call(null, object, element, args);
					}
				} catch(e) {
					if(e.name === "AssertionError") {
						e.message += " for '" + prop + "' with rule: " + JSON.stringify(rule);
					}
					throw e;
				}
			});
		},
		
		_checkRule: function(element, value, rule, object, args) {
			if(rule.text !== undefined && rule.text === true) {
				rule["tested"].text = true;
				expect(element.text()).to.equal(value);
			}
			if(rule.attr !== undefined) {
				rule["tested"].attr = true;
				for(var i = 0, len = rule.attr.length; i < len; i++) {
					expect(element.attr(rule.attr[i])).to.equal(value);
				}
			}
			if(rule.className !== undefined) {
				rule["tested"].className = true;
				if(typeof rule.className === "string") {
					var classes = rule.className.split(" ");
				} else {
					var classes = value.split(" ");
				}
				for(var i = 0, len = classes.length; i < len; i++) {
					expect(element.hasClass(classes[i])).to.be.true;
				}
			}
			if(rule.component !== undefined) {
				rule["tested"].component = true;
				if(rule.component.options !== undefined) {
					for(var i = 0, len = rule.component.options.length; i < len; i++) {
						if(rule.component.include !== undefined && rule.component.include === true) {
							expect(element[rule.component.name]("option", rule.component.options[i])).to.deep.include(value);
						} else {
							expect(element[rule.component.name]("option", rule.component.options[i])).to.equal(value);
						}
					}
				} else {
					expect(element[rule.component.name]("option")).to.deep.include(value);
				}
			}
			
			if(rule.visible !== undefined) {
				rule["tested"].visible = true;
				expect(value).to.equal(element.css("display") !== "none");
			}
			
			if(rule.contains !== undefined) {
				rule["tested"].contains = true;
				if(rule.contains.args !== undefined) {
					for(var i = 0, len = rule.contains.args.length; i < len; i++) {
						if(rule.contains.not === undefined || rule.contains.not === false) {
							if(typeof args[rule.contains.args[i]] === "object") {
								expect(value).to.deep.include(args[rule.contains.args[i]]);
							} else {
								expect(value).to.include(args[rule.contains.args[i]]);
							}
						} else {
							if(typeof args[rule.contains.args[i]] === "object") {
								expect(value).to.not.deep.include(args[rule.contains.args[i]]);
							} else {
								expect(value).to.not.include(args[rule.contains.args[i]]);
							}
						}
					}
				}
			}
			if(rule.length !== undefined) {
				rule["tested"].length = true;
				if(typeof rule.length === "number") {
					expect(value).to.have.length(rule.length);
				}
			}
			if(rule.empty !== undefined) {
				rule["tested"].empty = true;
				if(rule.empty === true) {
					expect(value).to.be.empty;
				} else {
					expect(value).to.not.be.empty;
				}
			}
			if(rule.custom !== undefined) {
				rule["tested"].custom = true;
				if(typeof value === "object") {
					expect((function() { return rule.custom.call(null, object, element, args); })()).to.deep.equal(value);
				} else {
					expect((function() { return rule.custom.call(null, object, element, args); })()).to.equal(value);
				}
			}
		},
		
		expectAllRulesTested: function(rules) {
			if(rules === undefined) {
				rules = this.rules;
			}
			this._iterateRules(rules, function(prop, rule) {
				try {
					for(var propRule in rule) {
						if(propRule !== "tested") {
							expect(rule.tested[propRule]).to.be.true;
						}
					}
				} catch(e) {
					if(e.name === "AssertionError") {
						e.message = "expected rule '" + JSON.stringify(rule) + "' for '" + prop + "' to have been tested";
					}
					throw e;
				}
			});
		},
		
		expectValidOption: function(optionName, type, empty, errorMessage, arrayType) {
			if(ALLOWED_OPTION_TYPES.indexOf(type) === -1) {
				throw new Error("Type isn't supported as valid option");
			}
			var that = this;
			var testObject = new TestObject(this.optionsDefinition, this.objectDefinitions);
			var options = testObject.createRandomObject();
			options[optionName] = null;
			expect(function() { $("<" + that.elementTag + ">")[that.componentName](options); }).to.throw(errorMessage);
			if(type !== "object") {
				options[optionName] = this._returnValidationVariable("object");
				expect(function() { $("<" + that.elementTag + ">")[that.componentName](options); }).to.throw(errorMessage);
			} else if(type === "object" && empty === false) {
				options[optionName] = this._returnValidationVariable("object", true);
				expect(function() { $("<" + that.elementTag + ">")[that.componentName](options); }).to.throw(errorMessage);
			}
			if(type !== "string") {
				options[optionName] = this._returnValidationVariable("string");
				expect(function() { $("<" + that.elementTag + ">")[that.componentName](options); }).to.throw(errorMessage);
			}
			if(type !== "number") {
				options[optionName] = this._returnValidationVariable("number");
				expect(function() { $("<" + that.elementTag + ">")[that.componentName](options); }).to.throw(errorMessage);
			}
			if(type !== "array") {
				options[optionName] = this._returnValidationVariable("array");
				expect(function() { $("<" + that.elementTag + ">")[that.componentName](options); }).to.throw(errorMessage);
			} else {
				if(empty === false) {
					options[optionName] = this._returnValidationVariable("array", true);
					expect(function() { $("<" + that.elementTag + ">")[that.componentName](options); }).to.throw(errorMessage);
				}
				if(arrayType !== undefined) {
					for(var i = 0, len = ALLOWED_OPTION_TYPES.length; i < len; i++) {
						if(ALLOWED_OPTION_TYPES[i] !== arrayType) {
							options[optionName] = [this._returnValidationVariable(ALLOWED_OPTION_TYPES[i])];
							expect(function() { $("<" + that.elementTag + ">")[that.componentName](options); }).to.throw(errorMessage);
						}
					}
				}
			}
			if(type !== "function") {
				options[optionName] = this._returnValidationVariable("function");
				expect(function() { $("<" + that.elementTag + ">")[that.componentName](options); }).to.throw(errorMessage);
			}
		},
		
		expectMethodsToExecuteOnAllOptions: function() {			
			var testObject = new TestObject(this.optionsDefinition, this.objectDefinitions);
			var state;
			do {
				state = testObject.getCurrentState();
				this.create(copyObject(state))
				this.expectMethodsToExecute(undefined, copyObject(state));
			} while(testObject.setNextState() === true)
		},
		
		expectMethodsToExecute: function(element, parent) {
			if(element === undefined) {
				element = this.element;
			}
			if(parent === undefined) {
				parent = element[this.componentName]("option");
			}
			
			for(var prop in this.methodDefinitions) {
				for(var i = 0, len = this.methodDefinitions[prop].length; i < len; i++) {
					var definition = this.methodDefinitions[prop][i]
					if(definition.args.length > 0) {
						var methodArgumentDefinition = {};
						for(var i = 0, len = definition.args.length; i < len; i++) {
							methodArgumentDefinition[i] = definition.args[i];
						}
						var methodTestObj = new TestObject(methodArgumentDefinition, this.objectDefinitions, false, 0, parent);
						var state;
						do {
							state = methodTestObj.getCurrentState();
							var args = [];
							for(var index in state) {
								args[parseInt(index)] = state[index];
							}
							 var value = element[this.componentName].apply(element, [prop].concat(args));
							 if(typeof definition.returnValue === "object") {
								 expect(value).to.deep.equal(definition.returnValue);
							 } else if(definition.returnValue !== undefined) {
								 expect(value).to.equal(definition.returnValue);
							 }
							this.expectElementToAbideByRules(undefined, element, definition.rules, args);
						} while(methodTestObj.setNextState() === true);
					} else {
						element[this.componentName].apply(element, [prop]);
						this.expectElementToAbideByRules(undefined, element, definition.rules, args);
					}
					this.expectAllRulesTested(definition.rules);
				}
			}
		},
		
		addBreakCondition: function(condition) {
			this.breakpoints.push(condition);
		},
		
		_returnValidationVariable: function(type, empty) {
			if(empty === undefined) {
				empty = false;
			}
			switch(type) {
				case "object": return empty===false?{ some: "prop" }:{};
				case "string": return "something";
				case "number": return 123;
				case "array": return empty===false?["something"]:[];
				case "function": return function() {};
				default: throw new Error("Type isn't supported as valid option");
			}
		},
		
		_validateRules: function(rules) {
			var that = this;
			var checkRule = function(prop, rule){
				for(var ruleProp in rule) {
					if(ALLOWED_RULE_PROPERTIES.indexOf(ruleProp) === -1) {
						throw new Error("Property '" + ruleProp + "' in rule isn't supported!");
					}
				}
			};
			this._iterateRules(this.rules, checkRule);
			TestDefinition.iterateDefinition(this.methodDefinitions, function(prop, definition) {
				that._iterateRules(definition.rules, checkRule);
			});
		},
		
		_validateDefinitions: function(){
			TestDefinition.validate(this.optionsDefinition);
			for(var prop in this.objectDefinitions) {
				TestDefinition.validate(this.objectDefinitions[prop]);
			}
			for(var prop in this.methodDefinitions) {
				TestDefinition.validate(this.methodDefinitions[prop].args);
			}
		},
		
		_iterateRules: function(rules, callback) {
			for(var prop in rules) {
				for(var propCount = 0, propLength = rules[prop].length; propCount < propLength; propCount ++) {
					var rule = rules[prop][propCount];
					callback.call(null, prop, rule);
				}
			}
		}
	}
	
	TestObject = function(definition, objectDefinitions, allCombinations, depth, parent) {
		if(allCombinations === undefined) {
			allCombinations = false;
		}
		if(depth === undefined) {
			depth = 0;
		}
		this.definition = definition;
		this.requiredProperties = Object.keys(definition).reduce(function(acc, key) { if(definition[key].required !== undefined && definition[key].required === true) { acc.push(key); } return acc; }, []);
		this.otherProperties = Object.keys(definition).reduce(function(acc, key) { if(definition[key].required === undefined || definition[key].required === false) { acc.push(key); } return acc; }, []);
		this.objectDefinitions = objectDefinitions;
		this.parent = parent;
		this.object = {};
		this.propPointers = {};
		this.propTestObjects = {};
		this.allCombinations = allCombinations;
		this.workingProperties = this.requiredProperties.concat(this.otherProperties);
		this.propertyPointer = 0
		this.uIDs = [];
		this.depth = depth;
		TestDefinition.validate(definition);
		this._resetToRequiredObject();
	}
	
	TestObject.prototype = {
		constructor: TestObject,
		
		setNextState: function() {
			var overflow = true;
			if(this.allCombinations === true) {
				this.propertyPointer = 0;
			}
			this._setUID();
			while(overflow === true) {
				if(this.definition[this.workingProperties[this.propertyPointer]].linkedWith === undefined && this.definition[this.workingProperties[this.propertyPointer]].type.indexOf("uniqID") === -1) {
					overflow = false;
					var pointers = this.propPointers[this.workingProperties[this.propertyPointer]];
					pointers.internalPointer++;
					if(this.definition[this.workingProperties[this.propertyPointer]].type[pointers.typePointer] !== "parent") {
						var value = this._fillInByType(this.definition[this.workingProperties[this.propertyPointer]].type[pointers.typePointer], pointers.internalPointer, this.workingProperties[this.propertyPointer]);
					} else {
						var value = null;
						this.object[this.workingProperties[this.propertyPointer]] = this._fillInByParent(this.workingProperties[this.propertyPointer]);
					}
					if(value === null) {
						pointers.internalPointer = 0;
						pointers.typePointer++;
						if(pointers.typePointer === this.definition[this.workingProperties[this.propertyPointer]].type.length) {
							pointers.typePointer = 0;
							overflow = true;
							if(this.propertyPointer+1 === this.workingProperties.length) {
								return false;
							}
						}
						value = this._fillInByType(this.definition[this.workingProperties[this.propertyPointer]].type[pointers.typePointer], pointers.internalPointer, this.workingProperties[this.propertyPointer]);
					}
					if(this.definition[this.workingProperties[this.propertyPointer]].type[pointers.typePointer-1] !== "parent") {
						this.object[this.workingProperties[this.propertyPointer]] = value;
					}
					this._adjustLinks(this.workingProperties[this.propertyPointer]);
				}
				if(overflow === true) {
					this.propertyPointer++;
					if(this.propertyPointer === this.workingProperties.length) {
						return false;
					}
				}
			};
			return true;
		},
		
		getCurrentState: function() {
			return this.object;
		},
		
		createRandomObject: function() {
			var object = {};
			for(var i = 0, len = this.workingProperties.length; i < len; i++) {
				var prop = this.workingProperties[i];
				if(this.definition[prop].type.indexOf("uniqID") === -1) {
					var randType = Math.floor(Math.random() * (this.definition[prop].type.length-1));
					if(this.definition[prop].type[randType] === "object" && this.definition[prop].values === undefined) {
						object[prop] = this._fillInObject(0, prop, true);
					} else if(this.definition[prop].type[randType] === "parent" && this.definition[prop].values === undefined) {
						object[prop] = this._fillInByParent(prop);
					} else {
						var randPointer = Math.floor(Math.random() * (this._maxPointerByType(this.definition[prop].type[randType], prop)-1));
						if(this.definition[prop].values !== undefined) {
							randPointer++;
						}
						object[prop] = this._fillInByType(this.definition[prop].type[randType], randPointer, prop);
					}
				} else {
					object[prop] = this.generateUID();
				}
			}
			return object;
		},
		
		_setUID: function() {
			for(var i = 0, len = this.workingProperties.length; i < len; i++) {
				if(this.definition[this.workingProperties[i]].type.indexOf("uniqID") !== -1) {
					this.object[this.workingProperties[i]] = this.generateUID();
					break;
				}
			}
		},
		
		_getOtherPropertyCombinations: function(pComb, pArr) {
			var combinations = [];
			for(var i = 0, len = pArr.length; i < len; i++) {
				if($.inArray(pArr[i], pComb) === -1) {
					var combination = pComb.concat(pArr[i]);
					combinations.push(combination)
					combinations = combinations.concat(this._getOtherPropertyCombinations(combination, pArr));
				}
			}
			
			for(var i = combinations.length - 1; i >= 0; i--) {
				if(combinations.length <= i) {
					i = combinations.length - 1;
				}
				var combination = combinations[i];
				for(var j = i - 1; j >= 0; j--) {
					var notInArray = false;
					if(combinations[j].length === combination.length) {
						for(var k = combinations[j].length - 1; k >= 0; k--) {
							if($.inArray(combinations[j][k], combination) === -1) {
								notInArray = true;
								break;
							}
						}
					} else {
						notInArray = true;
					}
					if(notInArray === false) {
						combinations.splice(j, 1);
					}
				}
			}
			return combinations;
		},
		
		_resetToRequiredObject: function() {
			this.object = {};
			this._setUID();
			for(var i = 0, len = this.workingProperties.length; i < len; i++) {
				this.propPointers[this.workingProperties[i]] = { typePointer: 0, internalPointer: 0 };
				if(this.definition[this.workingProperties[i]].type[0] !== "parent" && this.definition[this.workingProperties[i]].linkedWith === undefined && this.definition[this.workingProperties[i]].type.indexOf("uniqID") === -1) {
					this.object[this.workingProperties[i]] = this._fillInByType(this.definition[this.workingProperties[i]].type[0], 0, this.workingProperties[i]);
					this._adjustLinks(this.workingProperties[i]);
				} else if(this.definition[this.workingProperties[i]].type[0] === "parent") {
					this.object[this.workingProperties[i]] = this._fillInByParent(this.workingProperties[i]);
				}
			}
		},
		
		_adjustLinks: function(prop) {
			for(var i = 0, len = this.workingProperties.length; i < len; i++) {
				if(this.definition[this.workingProperties[i]].linkedWith !== undefined && this.definition[this.workingProperties[i]].linkedWith.indexOf(prop) != -1) {
					if(typeof this.definition[this.workingProperties[i]].values !== "function") {
						throw new Error("A definition with 'linkedWith' should have the 'values' property added!")
					}
					this.object[this.workingProperties[i]] = this._fillInValues(0, this.workingProperties[i]);
				}
			}
		},
		
		_fillInByType: function(type, pointer, prop, random) {
			if(pointer === 0 && (this.definition[prop].required === undefined || this.definition[prop].required === false)) {
				return undefined;
			} else if(pointer === 0) {
				pointer++;
				this.propPointers[prop].internalPointer++;
			}
			if(this.definition[prop].values !== undefined) {
				return this._fillInValues(pointer, prop);
			}
			switch(type) {
				case "string": return this._fillInString(pointer, prop);
				case "boolean": return this._fillInBoolean(pointer, prop);
				case "number": return this._fillInNumber(pointer, prop);
				case "date": return this._fillInDate(pointer, prop);
				case "array": return this._fillInArray(pointer, prop);
				case "object": return this._fillInObject(pointer, prop);
				case "test": return this._fillInTest(pointer, prop);
				default: throw new Error("Type " + type + " isn't supported!");
			}
		},
		
		_maxPointerByType: function(type, prop) {
			if(this.definition[prop].values !== undefined) {
				return this.definition[prop].values.length + 1;
			}
			var val;
			var pointer = 1;
			do {
				switch(type) {
					case "string": val = this._fillInString(pointer, prop); break;
					case "boolean": val = this._fillInBoolean(pointer, prop); break;
					case "number": val = this._fillInNumber(pointer, prop); break;
					case "date": val = this._fillInDate(pointer, prop); break;
					case "array": val = this._fillInArray(pointer, prop); break;
					case "test": val = this._fillInTest(pointer, prop); break;
					default: return 0;
				}
				pointer++;
			} while(val !== null);
			return pointer;
		},
		
		_fillInValues: function(pointer, prop) {
			if(typeof this.definition[prop].values === "function") {
				if(pointer === 4) {
					return null;
				}
				return this.definition[prop].values.call(null, copyObject(this.object));
			}
			if(this.definition[prop].values.length === pointer-1) {
				return null;
			}
			var val = this.definition[prop].values[pointer-1];
			if(typeof val === "string" && val.indexOf("__") === 0) {
				switch(val.substring(2)) {
					case "now": return Date.now();
					case "nowISO": return new Date().toISOString();
				}
			}
			return val;
		},
		
		_fillInByParent: function(prop) {
			if(typeof this.definition[prop].values === "function") {
				return this.definition[prop].values.call(null, copyObject(this.object), copyObject(this.parent));
			}
			else if(this.definition[prop].property !== undefined) {
				return TestDefinition.getValue(this.parent, this.definition[prop].property);
			}
			throw new Error("The parent type requires either a 'values' function or a 'property'!")
		},
		
		_fillInDate: function(pointer, prop) {
			var date = new Date();
			switch(pointer) {
				case 1: return date.valueOf();
				case 2: return date.toISOString();
				case 3: date.setYear(2000); return date.valueOf();
				case 4: date.setYear(2000); return date.toISOString();
				case 5: date.setYear(3000); return date.valueOf();
				case 6: date.setYear(3000); return date.toISOString();
				default: return null;
			}
		},
		
		_fillInString: function(pointer, prop) {
			switch(pointer) {
				case 1: if(this.definition[prop].empty === undefined || this.definition[prop].empty === true) { return ""; } else { this.propPointers[prop].internalPointer++; };
				case 2: return "a";
				case 3: return "ab";
				default: return null;
			}
		},
		
		_fillInBoolean: function(pointer, prop) {
			switch(pointer) {
				case 1: return false;
				case 2: return true;
				default: return null;
			}
		},
		
		_fillInNumber: function(pointer, prop) {
			switch(pointer) {
				case 1: return -10;
				case 2: return 0;
				case 3: return 10;
				default: return null;
			}
		},
		
		_fillInArray: function(pointer, prop) {
			if(this.definition[prop].objectType !== undefined) {
				if(MAX_DEPTH_TEST_OBJECT > this.depth) {
					var objDefinition = this._getObjectDefinition(this.definition[prop].objectType);
					var depth = this.depth;
					if(JSON.stringify(objDefinition) === JSON.stringify(this.definition)) {
						depth++;
					}
					var obj = new TestObject(objDefinition, this.objectDefinitions, this.allCombinations, depth);
					if(this.definition[prop].length !== undefined) {
						if(pointer === 1) {
							var val = [];
							for(var i = 0; i < this.definition[prop].length; i++) {
								val.push(obj.createRandomObject());
							}
							return val;
						} else {
							return null;
						}
					} else {
						switch(pointer) {
							case 1: return [obj.createRandomObject(), obj.createRandomObject(), obj.createRandomObject()];
							case 2: return [obj.createRandomObject()];
							case 3: if(this.definition[prop].empty === undefined || this.definition[prop].empty === true) { return []; } else { this.propPointers[prop].internalPointer++; };
							case 4: return [obj.createRandomObject(), obj.createRandomObject()];
							default: return null;
						}
					}
				} else {
					return null;
				}
			} else {
				switch(pointer) {
					case 1: return ["10", "20", "30"];
					case 2: return ["10"];
					case 3: if(this.definition[prop].empty === undefined || this.definition[prop].empty === true) { return []; } else { this.propPointers[prop].internalPointer++; };
					case 4: return ["10", "20"];
					default: return null;
				}
			}
		},
		
		_fillInTest: function(pointer) {
			switch(pointer) {
				case 1: return "a";
				default: return null;
			}
		},
		
		_fillInObject: function(pointer, prop, random) {
			if(random === undefined) {
				random = false;
			}
			var objDefinition = this._getObjectDefinition(this.definition[prop].objectType);
			if(JSON.stringify(objDefinition) !== JSON.stringify(this.definition) || MAX_DEPTH_TEST_OBJECT > this.depth) {
				if(this.propTestObjects[prop] === undefined || pointer === 0) {
					var depth = this.depth;
					if(JSON.stringify(objDefinition) === JSON.stringify(this.definition)) {
						depth++;
					}
					var obj = 
					this.propTestObjects[prop] = new TestObject(objDefinition, this.objectDefinitions, this.allCombinations, depth);
					if(random === false) {
						return this.propTestObjects[prop].getCurrentState();
					} else {
						return this.propTestObjects[prop].createRandomObject();
					}
				} else {
					if(random === false) {
						if(this.propTestObjects[prop].setNextState() === true) {
							return this.propTestObjects[prop].getCurrentState();
						} else {
							this.propTestObjects[prop] === undefined;
							return null;
						}
					} else {
						return this.propTestObjects[prop].createRandomObject();
					}
				}
			} else {
				if(random === true) {
					return undefined;
				} else {
					return null;
				}
			}
		},
		
		_getObjectDefinition: function(objectType) {
			if(this.objectDefinitions[objectType] !== undefined) {
				return this.objectDefinitions[objectType];
			} else {
				throw new Error("Object type '" + objectType + "' isn't included in 'objectDefinitions'");
			}
		},
		
		s4: function() {
		    return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
		},
		
		generateUID: function() {
			do {
				var uid = this.s4() + this.s4() + '-' + this.s4() + '-' + this.s4() + '-' + this.s4() + '-' + this.s4() + this.s4() + this.s4();
			}
			while(this.uIDs.indexOf(uid) !== -1);
			this.uIDs.push(uid)
			return uid;
		}
	}
	
	TestDefinition = function() {
		
	}
	
	TestDefinition.validate = function(definition) {
		TestDefinition.iterateDefinition(definition, TestDefinition._validation);
	}
	
	TestDefinition._validation = function(prop, definition) {
		for(var defProp in definition) {
			if(ALLOWED_DEFINITION_PROPERTIES.indexOf(defProp) === -1) {
				throw new Error("Property '" + defProp + "' in definition isn't supported!");
			}
		};
		if(typeof definition.type !== "object" || typeof definition.type.length !== "number" || definition.type.length === 0) {
			throw new Error("Property type in definition should be an array and not be empty!");
		}
		for(var i = 0, len = definition.type.length; i < len; i++) {
			if(ALLOWED_DEFINITION_TYPES.indexOf(definition.type[i]) === -1) {
				throw new Error("Type '" + definition.type[i] + "' in definition isn't supported!");
			}
		}
	}

	TestDefinition.iterateDefinition = function(definition, callback) {
		for(var prop in definition) {
			callback.call(null, prop, definition[prop]);
		}
	}
	
	TestDefinition.getValue = function(pObject, pField) {
	    var subKeys = pField.split('.');
	    var subObject = pObject;
	    for (var i = 0, len = subKeys.length; i < len; i++) {
	    	var subKey = subKeys[i];
            if (subObject[subKey] === undefined) {
		        return;
            }
            subObject = subObject[subKey];
	    }
	    return subObject;
	}
})();

if(typeof module !== "undefined") {
	module.exports = { WidgetUnitTestObject, TestObject };
}