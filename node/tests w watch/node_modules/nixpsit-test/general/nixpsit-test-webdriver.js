const webdriver = require("selenium-webdriver");
const proxy = require("selenium-webdriver/proxy");
const config = require("./nixpsit-test-config.js");
const connection = require("./nixpsit-test-connection.js");
const http = require('http');
const fs = require('fs');
const util = require('util');

var indents = 0;
function indent() {
	return Array(indents).join('  ');
}
function speedColor(speed) {
	if(speed === "fast") {
		return "\x1b[32m";
	} else if(speed === "medium") {
		return "\x1b[33m";
	} else if(speed === "slow") {
		return "\x1b[31m";
	} else {
		return "\x1b[30m";
	}
}

var proxyServer = http.createServer().listen(3000);
proxyServer.keepAliveTimeout = 30000;
proxyServer.on("request", function(request, response) {
	var url = request.url;
	var relative = false;
	if(url.indexOf("http:") === -1) {
		url = "http://" + request.headers["host"] + url;
		relative = true;
	}
	var parsedUrl = new URL(url);
	if(parsedUrl.pathname !== "/nixpsit") {
		if(parsedUrl.hostname !== "cfclient") {
			let options;
			if(relative === false && parsedUrl.hostname !== "127.0.0.1" && parsedUrl.hostname !== "localhost" && parsedUrl.port !== 3000) {
				options = {
					hostname: parsedUrl.hostname,
					protocol: parsedUrl.protocol,
					port: parsedUrl.port,
					path: parsedUrl.pathname + parsedUrl.search,
					method: request.method,
					headers: request.headers
				}
			} else {
				options = {
					hostname: config.getSetting("hostname"),
					protocol: config.getSetting("protocol"),
					port: config.getSetting("port"),
					path: parsedUrl.pathname + parsedUrl.search,
					method: request.method,
					headers: request.headers
				}
			}
			delete options.headers["if-none-match"];
			delete options.headers["if-modified-since"];
			options.headers["Access-Control-Allow-Origin"] = "*";
			let proxy = http.request(options, function(res) {
				var headers = res.headers;
				for(let prop in headers) {
					response.setHeader(prop, headers[prop]);
				}
				response.statusCode = res.statusCode;
				response.statusMessage = res.statusMessage;
			    res.pipe(response);
			});
			request.pipe(proxy);
		} else {
			response.statusCode = 404;
			response.end();
		}
	} else {
		let fileStream = fs.createReadStream(decodeURIComponent(parsedUrl.searchParams.get("get_local_file")));
		fileStream.pipe(response);
	}
});

class NiXPSITWebdriver {
	constructor() {
		this.webdriver;
		this.webdriverLogTimeoutID;
		
		this.mochaTestsResolve;
	}
	
	open(browser) {
		var proxySettings = {
			http: "127.0.0.1:3000"
		}
		if(browser === "chrome") {
			const chrome = require('selenium-webdriver/chrome');
			const chromePath = require('chromedriver').path;
			const chromeService = new chrome.ServiceBuilder(chromePath)
			
			let chromeCapabilities = webdriver.Capabilities.chrome();
			let args = [];
			if(config.getSetting("headless_tests") === true) {
				args.push("--headless");
			}
			if(config.getSetting("open_dev_tools") === true) {
				args.push("--auto-open-devtools-for-tabs");
			}
			chromeCapabilities.set('chromeOptions', { args: args });
			this.webdriver = new webdriver.Builder().setChromeService(chromeService).withCapabilities(chromeCapabilities).setProxy(proxy.manual(proxySettings)).build();
		} else if(browser === "firefox") {
			const firefox = require('selenium-webdriver/firefox');
			const geckodriver = require('geckodriver');
			const geckoService = new firefox.ServiceBuilder(geckodriver.path);
			//Uncomment this for more debugging output
			//geckoService.enableVerboseLogging(true);
			//geckoService.setStdio(['pipe', 1, 'pipe']);
			
			let firefoxCapabilities = webdriver.Capabilities.firefox();
			let args = ["-new-instance"];
			if(config.getSetting("headless_tests") === true) {
				args.push("-headless");
			}
			if(config.getSetting("open_dev_tools") === true) {
				args.push("-devtools");
			}
			firefoxCapabilities.set('moz:firefoxOptions', { args: args });
			this.webdriver = new webdriver.Builder().setFirefoxService(geckoService).withCapabilities(firefoxCapabilities).setProxy(proxy.manual(proxySettings)).build();
		}
		let that = this;
		this.webdriverLogIntervalID = setInterval(async function() {
			if(that.webdriver !== undefined) {
				let i, len;
				let mochaLogs = await that.webdriver.executeScript(function() { 
					if(window.mochaLogs !== undefined) {
						var logs = window.mochaLogs;
						window.mochaLogs = [];
						return logs; 
					} else { 
						return []; 
					}
				});
				for(i = 0, len = mochaLogs.length; i < len; i++) {
					var json = JSON.parse(mochaLogs[i]);
					that._log(json.data);
				}
				let logs = await that.webdriver.executeScript(function() { 
					if(window.consoleLogs !== undefined) {
						var logs = window.consoleLogs;
						window.consoleLogs = [];
						return logs; 
					} else {
						return []; 
					}
				});
				for(i = 0, len = logs.length; i < len; i++) {
					try {
						console.log(JSON.parse(logs[i]));
					} catch(e) {
						console.log(logs[i]);
					}
				}
				let errorLogs = await that.webdriver.executeScript(function() { 
					if(window.consoleLogs !== undefined) {
						var errorLogs = window.consoleErrorLogs;
						window.consoleErrorLogs = [];
						return errorLogs; 
					} else {
						return []; 
					}
				});
				for(i = 0, len = errorLogs.length; i < len; i++) {
					try {
						var e = JSON.parse(errorLogs[i]);
						console.error(e);
					} catch(e) {
						var e = errorLogs[i];
						console.error(e);
					}
				}
			}
		}, 1000);
	}
	
	async get(url) {
		url = this._convertSource(url);
		await this.webdriver.get(url);
		await this.webdriver.executeScript(function(){
			window.consoleLogs = [];
			window.consoleErrorLogs = [];
			window.consoleLog = window.console.log;
			window.consoleError = window.console.error;
			window.consoleWarn = window.console.warn;
			window.consoleException = window.console.exception;
			window.consoleDebug = window.console.debug;

			function pushToLog(log) {
				try { 
					window.consoleLogs.push(JSON.stringify(log));
				} catch(e) {
					window.consoleLogs.push(log);
				}
			}

			window.console.log = function() {
				pushToLog(arguments[0]);
				window.consoleLog.apply(console, arguments);
			}
			window.console.error = function() {
				try {
					window.consoleErrorLogs.push(JSON.stringify(arguments[0]));
				} catch(e) {
					window.consoleErrorLogs.push("Error occured! Check browser for more info!");
				}
				window.consoleError.apply(console, arguments);
			}
			window.console.warn = function() {
				pushToLog(arguments[0]);
				window.consoleWarn.apply(console, arguments);
			}
			window.console.exception = function() {
				pushToLog(arguments[0]);
				window.consoleException.apply(console, arguments);
			}
			window.console.debug = function() {
				pushToLog(arguments[0]);
				window.consoleDebug.apply(console, arguments);
			}
			window.onerror = function(message, source, lineno, colno, error) {
				window.consoleErrorLogs.push(message + " at " + source + ":" + lineno + ":" + colno);
			}
		});
	}
	
	getWebdriver() {
		return this.webdriver;
	}
	
	setMochaResolve(resolve) {
		this.mochaTestsResolve = resolve;
	}
	
	_log(data) {
		if(data[0] === "start") {
			console.log("Starting tests: a total of " + data[1].total + (typeof data[1].grep==="string"&&data[1].grep.length>0?" with grep: " + data[1].grep:""));
			indents++
		}
		if(data[0] === "suite") {
			console.log(indent() + "Starting suite: " + data[1].title);
			indents++
		}
		if(data[0] === "pass") {
			console.log(indent() + '\x1b[32m\u221A\x1b[0m ' + data[1].title + " " + speedColor(data[1].speed)  + "(" + data[1].duration + "ms)\x1b[0m");
		}
		if(data[0] === "fail") {
			console.log(indent() + "\x1b[31m\u00D7 " + data[1].title + "\x1b[0m");
			console.log(indent() + "\x1b[31m  Error: " + data[1].err + "\x1b[0m");
			if(data[1].prop !== undefined) {
				console.log(indent() + "\x1b[31m  For property:\x1b[0m");
				this._logObject(data[1].prop, indent() + "         ");
			}
			if(data[1].expectation !== undefined) {
				console.log(indent() + "\x1b[31m  With expectation:\x1b[0m");
				this._logObject(data[1].expectation, indent() + "         ");
			}
			if(data[1].options !== undefined) {
				console.log(indent() + "\x1b[31m  Using options:\x1b[0m");
				this._logObject(data[1].options, indent() + "         ");
			}
			if(data[1].prevOptions !== undefined) {
				console.log(indent() + "\x1b[31m  With previous options:\x1b[0m");
				this._logObject(data[1].prevOptions, indent() + "         ");
			}
			if(data[1].args !== undefined) {
				console.log(indent() + "\x1b[31m  On " + data[1].method + " with arguments:\x1b[0m");
				this._logObject(data[1].args, indent() + "         ");
			}
			if(data[1].stack !== undefined) {
				console.log(indent() + "\x1b[31m  Stack: " + data[1].stack.replace(/\n/g, "\n" + indent() + "         ") + "\x1b[0m");
			}
			if(data[1].actual !== undefined && data[1].expected !== undefined && typeof data[1].actual === "object" && typeof data[1].expected === "object") {
				console.log(indent() + "  Difference:");
				indents++;
				this._showDiff(data[1].actual, data[1].expected);
				indents--;
			}
		}
		if(data[0] === "pending") {
			console.log(indent() + "\x1b[36m. " + data[1].title + "\x1b[0m");
		}
		if(data[0] === "suite end") {
			indents--;
			//console.log(indent() + "Suite ended");
		}
		if(data[0] === "end") {
			indents--;
			console.log("Tests ended: \x1b[32m# passed " + data[1].passed + "\x1b[0m, \x1b[36m# pending " + data[1].pending + "\x1b[0m, \x1b[31m# failed " + data[1].failed + "\x1b[0m");
			if(this.mochaTestsResolve !== undefined) {
				this.mochaTestsResolve();
			}
		}
	}
	
	_logObject(object, indent) {
		console.log(indent + util.inspect(object, { colors: true, depth: 3 }).replace(/\n/g, "\n" + indent));
	}
	
	_showDiff(actual, expected) {
		if(actual !== null && expected !== null && actual !== undefined && expected !== undefined) {
			console.log(indent() + "{");
			indents++;
			let propsActual = Object.getOwnPropertyNames(actual);
			let propsExpected = Object.getOwnPropertyNames(expected);
			
			for(let i = 0, len = propsActual.length; i < len; i++) {
				let indexExpected = propsExpected.indexOf(propsActual[i]); 
				if(indexExpected  === -1) {
					console.log(indent() + "\x1b[31mexpected property: " + propsActual[i] + "\x1b[0m");
				} else {
					this._showDiffOfProperty(actual[propsActual[i]], expected[propsExpected[indexExpected]], propsActual[i]);
					propsExpected.splice(indexExpected, 1);
				}
			}
			
			for(let i = 0, len = propsExpected.length; i < len; i++) {
				console.log(indent() + "\x1b[31mactual property: " + propsExpected[i] + "\x1b[0m");
			}
			
			indents--;
			console.log(indent() + "}");
		} else {
			console.log(indent() + "\x1b[31mexpected " + actual + " to be " + expected + "\x1b[0m");
		}
	}
	
	_showDiffOfProperty(actualProp, expectedProp, nameProp) {
		if(typeof actualProp !== typeof expectedProp || Array.isArray(actualProp) !== Array.isArray(expectedProp)) {
			console.log(indent() + "\x1b[31mtype difference of property " + nameProp + " -- expected: " + (typeof expectedProp) + " actual: " + (typeof actualProp) + "\x1b[0m");
		} else if(Array.isArray(actualProp)) {
			
			let actualLength = actualProp.length;
			let expectedLength = expectedProp.length;
			if(actualLength !== expectedLength) {
				console.log(indent() + "\x1b[31mlength difference of array: " + nameProp + " -- expected: " + expectedLength + " actual: " + actualLength + "\x1b[0m");
			} else {
				console.log(indent() + "[");
				indents++;
				
				for(let i = 0; i < actualLength; i++) {
					this._showDiffOfProperty(actualProp[i], expectedProp[i], i);
				}
				
				indents--;
				console.log(indent() + "]");
			}
		} else if(typeof actualProp === "object") {
			this._showDiff(actualProp, expectedProp);
		} else if(actualProp !== expectedProp) {
			console.log(indent() + "\x1b[31mvalue difference of " + (typeof nameProp === "number"?"index":"property") + " " + nameProp + " -- expected: " + expectedProp + " actual: " + actualProp + "\x1b[0m");
		} else {
			console.log(indent() + "\x1b[32m" + nameProp + ": " + expectedProp + "\x1b[0m");
		}
	}

	async loadAllStyles(styles) {
		for(let i = 0, len = styles.length; i < len; i++) {
			var source = this._convertSource(styles[i]);
			this.webdriver.executeScript(function(source) {
				var style = document.createElement("link");
				style.rel = "stylesheet";
				style.href = source;
				document.head.appendChild(style);
			}, source);
		}
	}

	async loadTranslations(pTranslations) {
		var translationJSON = {};
		for(var i = 0, len = pTranslations.length; i < len; i++) {
			 Object.assign(translationJSON, await connection.fetchJSON(pTranslations[i])); 
		}
		await this.webdriver.executeScript(function(pTranslations) {
			$.i18n.setDictionary(pTranslations);
		}, translationJSON);
	}
	
	async loadAll(scripts) {
		for(let i = 0, len = scripts.length; i < len; i++) {
			await this.addScriptAsync(scripts[i]);
		}
	}
	
	addScriptAsync(source) {
		var that = this;
		source = this._convertSource(source);
		return new Promise(async function(resolve, reject) {
			await that.webdriver.executeScript(function(source) {
				window.scriptloaded = false;
				var script = document.createElement("script");
				script.type = "text/javascript";
				script.src = source
				script.addEventListener("load", function(event) {
					window.scriptloaded = true;
				});
				document.head.appendChild(script);
			}, source);
			var count = 0;
			do {
				var loaded = await that.webdriver.executeScript(function() { return window.scriptloaded });
			} while(loaded === false && count++ < 1000);
			if(count !== 1000) {
				resolve();
			} else {
				reject();
			}
		});
	}
	
	_convertSource(source) {
		if(source.indexOf("http://") === -1 && source.indexOf("https://") === -1 && source.indexOf("file:///") === -1 && source.indexOf("./") !== 0 && source.indexOf("/") !== 0) {
			source = "http://127.0.0.1:3000/nixpsit?get_local_file=" + encodeURIComponent(source);
		} else if(source.indexOf("http://127.0.0.1:") === 0) {
			source = "http://127.0.0.1:3000" + source.substr(source.indexOf("/", 7));
		} else if(source.indexOf("https://127.0.0.1:") === 0) {
			source = "http://127.0.0.1:3000" + source.substr(source.indexOf("/", 8));
		}
		return source;
	}
	
	async close() {
		try {
			clearInterval(this.webdriverLogIntervalID);
			this.webdriverLogIntervalID = undefined;
			
			let driverToClose = this.webdriver;
			this.webdriver = undefined;
			await driverToClose.close();
		} catch(e) {
			
		}
	}
}

module.exports = NiXPSITWebdriver;